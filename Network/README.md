# Part 네트워크

### 질문 목록
 * [OSI 7계층이란 무엇인가요?](#osi-7계층이란-무엇인가요)
 * [TCP와 UDP의 차이를 설명해주세요](#tcp와-udp의-차이를-설명해주세요)
 * [3-way handshake 과정은 무엇인가요?](#3-way-handshake-과정은-무엇인가요)
 * [4-way handshake 과정은 무엇인가요?](#4-way-handshake-과정은-무엇인가요)
 * [흐름 제어란 무엇인가요?](#흐름-제어flow-control란-무엇인가요)
 * [혼잡 제어란 무엇인가요?](#혼잡-제어congestion-control란-무엇인가요)
---
## OSI 7계층이란 무엇인가요?
OSI 7계층은 네트워크 통신 과정을 표준화하기 위해 국제표준화기구(ISO)가 정의한 모델로, 통신 과정을 7단계로 분리하여 각 단계가 명확한 역할을 수행하도록 설계되었습니다. 이 계층화로 인해 서로 다른 제조사와 기술을 사용해도 상호 호환이 가능해집니다.

OSI 7계층은 물리, 데이터 링크, 전송, 세션, 표현, 응용 계층으로 구성됩니다. 각 계층은 바로 아래 계층의 서비스를 이용하고, 바로 위 계층에 서비스를 제공합니다. 이렇게 계층을 나누면 문제 발생 시 특정 계층에서 원인을 분석할 수 있고 설계와 유지보수가 용이해집니다.

예를 들어 사용자가 브라우저를 통해 웹페이지를 요청하면, 응용 계층에서 요청 데이터를 만들고, 표현 계층에서 *인코딩, *암호화를 처리하며, 세션 계층에서 연결 상태를 관리합니다. 전송 계층에서 데이터를 [세그먼트](../Programming%20Terminology/README.md#세그먼테이션)로 분할하고 네트워크 계층에서 IP 주소 기반 [라우팅]을 수행하며, 데이터 링크 계층에서  MAC 주소 기반 프레임을 만들고, 물리 계층에서 이를 전기, 광 신호로 전송합니다. 실무에서는 OSI 모델을 문제 분석의 틀로 활용하며, 예를 들어 *패킷 유실 문제는 전송 계층, 라우팅 문제는 네트워크 계층에서 주로 진단합니다.

---
## TCP와 UDP의 차이를 설명해주세요.
[TCP]와 [UDP]는 전송 계층의 대표적인 프로토콜입니다. TCP는 연결 설정([3-way handshake](#3-way-handshake-과정은-무엇인가요))를 거친 후 데이터를 전송하며, 데이터 순서 보장, 재전송, 흐름 제어, 혼잡 제어를 제공합니다. <br>
반면 UDP는 이러한 기능이 없고, 헤더가 단순해 전송 속도가 빠릅니다. TCP는 파일 전송, 웹서비스에 UDP는 실시간 스트리밍, 게임, [VoIP]에 주로 사용됩니다.

TCP는 20바이트 이상의 헤더를 사용하며 시퀀스 번호, [ACK 번호], 플래그를 통해 데이터 순서를 보장합니다. 손실이 발생하면 재전송을 수행하고, 네트워크 상태에 따라 전송 속도를 조절합니다. 반면 UDP는 8바이트 고정 길이 헤더만 사용하고, 연결 설정 없이 데이터를 전송합니다. 이로 인해 [패킷] 손실 가능성이 있지만, 실시간성이 중요한 환경에서는 손실보다 지연이 더 큰 문제가 되므로 UDP를 선호합니다. 

---
## 3-way handshake 과정은 무엇인가요?
TCP에서 연결을 성립하기 위해 사용하는 3단계 과정입니다. 클라이언트와 서버가 서로의 통신 가능 여부를 확인하고 초기 시퀀스 번호를 교환합니다.

1단계 : 클라이언트가 서버에 [SYN] [패킷] 전송<br>
2단계 : 서버가 SYN - [ACK] 패킷 응답<br>
3단계 : 클라이언트가 ACK 패킷 전송<br>
이 과정을 통해 양측은 데이터를 안전하게 전송할 준비를 마칩니다.

3-way handshake는 TCP가 신뢰성을 확보하는 핵심 절차입니다. 첫 번째 SYN에서 클라이언트는 초기 시퀀스 번호(ISN)를 보내고, 서버는 이를 수신 후 자신의 ISN과 함께 SYN - ACK로 응답합니다. 마지막 ACK로 서버의 ISN을 확인하면 연결이 성립됩니다. 이 과정에서 각 측은 상대의 수신 가능 여부와 네트워크 경로의 정상 여부를 검증합니다. 만약 이 과정이 생략되면 잘못된 연결, 중간자 공격 등의 위험이 커집니다.

---
## 4-way handshake 과정은 무엇인가요?
TCP 연결을 정상적으로 종료하는 절차입니다. 양측이 독립적으로 연결 종료 의사를 전달하고, 남아 있는 데이터를 전송합니다.

1단계 : 클라이언트가 [FIN] 패킷 전송<br>
2단계 : 서버가 [ACK] 응답 <br>
3단계 : 서버가 FIN 전송 <br>
4단계 : 클라이언트가 ACK 응답 <br>
이후 연결이 완전히 종료됩니다.

TCP 종료 과정은 각 방향의 데이터 전송을 독립적으로 닫기 위해 4단계로 나뉩니다. 클라이언트가 FIN을 보내면 서버는 ACK를 보낸 후 남은 데이터를 전솔할 수 있습니다. 데이터 전송이 끝니면 서버가 FIN을 보내고, 클라이언트가 마지막 ACK를 보내면 연결이 종료됩니다. 이때 TIME_WAIT 상태가 발생하여 지연된 패킷이 네트워크에 남아 있어도 혼동을 방지합니다.

---
## 흐름 제어(Flow Control)란 무엇인가요?
흐름 제어는 송신 측이 수신 측의 처리 속도를 초과하지 않도록 전송 속도를 조절하는 기능입니다. TCP에서 수신 측의 버퍼 상태에 따라 전송 윈도우 크기를 조정합니다.

수신 측이 자신의 버퍼 크기에 맞춰 수신 윈도우 크기를 알려주면, 송신 측은 이 크기를 초과하지 않게 데이터를 전송합니다. 이를 통해 버퍼 [오버플로]와 패킷 손실을 방지합니다.

흐름 제어는 주로 [슬라이딩 윈도우(Sliding window)] 방식으로 구현됩니다. 송신 측은 수신 측에서 전달한 윈도우 크기만큼 데이터 세그먼트를 보내고, ACK를 받으면 윈도우를 이동시키며 전송을 이어갑니다. 예를 들어 수신 측 버퍼가 8KB이고, 현재 4KB가 찼다면, 송신 측은 최대 4KB까지만 보낼 수 있습니다. 이를 무시하면 패킷 손실과 재전송이 빈번해져 성능이 떨어집니다.

---
## 혼잡 제어(Congestion Control)란 무엇인가요?
혼잡 제어는 네트워크 내에 패킷이 과도하게 몰려서 성능이 급격히 저하되는 현상을 방지하기 위해, 송신 측이 전송 속도를 네트워크 상황에 맞춰 조절하는 기술입니다.

TCP는 혼잡 제어를 위해 네 가지 대표적인 알고리즘을 사용합니다. [Slow Start]. [Congestion Avoidance], [Fast Retransmit]. [Fast Recovery]가 그것입니다. 이들은 네트워크 혼잡을 감지하고, 윈도우 크기를 늘리거나 줄이는 방식으로 동작합니다.

TCP 혼잡 제어의 핵심은 네트워크 혼잡을 사전에 감지하고 대역폭을 효율적으로 활용하는 것입니다. 예를 들어 Slow Start 단계에서는 초기 전송 윈도우를 작게 시작해 매 RTT마다 두 배씩 증가시킵니다. 혼잡이 감지되면 Congestion Avoidance로 전환하여 선형 증가로 전송 속도를 조절합니다. Fast Retransmit은 3개의 중복 ACK를 받으면 재전송을 즉시 수행하고, Fast Recovery는 혼잡 윈도우를 절반으로 줄인 뒤 점진적으로 회복시킵니다.

---
## MTU(Maximum Transmission Unit)란 무엇인가요?
MTU는 네트워크 계층에서 하나의 패킷이 전송될 수 있는 최대 크기를 의미합니다. MTU보다 큰 데이터는 쪼개져 전송됩니다.

일반적인 이더넷의 MTU는 1500바이트입니다. 이를 초과하면 [IP 단편화]가 발생하는데, 이는 성능 저하와 재조립 부담을 유발할 수 있습니다.

MTU는 네트워크 장비와 프로토콜에 따라 다릅니다. 예를 들어 [VPN]이나 [GRE 터널]을 사용할 경우 캡슐화 헤더 때문에 실제 데이터 MTU가 줄어듭니다. [Path MTU Discovery(PMTUD)]는 경로상의 모든 링크 MTU 중 가장 작은 값을 찾아 단편화를 방지합니다. MTU 설정이 부적절하면 패킷 손실, 전송 지연, 심지어 연결 끊김 문제가 발생할 수 있습니다.

---
## DNS의 동작 원리를 설명해주세요.
DNS는 사람이 이해하기 쉬운 도메인 이름을 IP 주소로 변환하는 시스템입니다.

클라이언트가 도메인 요청을 보내면, 로컬 DNS 캐시 -> 재귀적 조회 -> 루트 네임서버 -> TLD 서버 -> 권한 있는 네임 서버 순으로 탐색하여 IP를 반환합니다.

DNS는 계층적 구조로 동작합니다. 먼저 브라우저나 OS 캐시에서 IP를 찾고, 없으면 로컬 DNS 서버가 재귀적 조회를 수행합니다. 루트 네임서버는 .com, .org 같은 TLD 서버 주소를 알려주고, TLD 서버는 해당 도메인의 권한 있는 네임서버를 반환합니다. 최종적으로 권한 서버가 IP를 응답하면, 이 값은 TTL(Time To Live) 동안 캐싱됩니다. 

---
## HTTP와 HTTPS의 차이는 무엇인가요?
HTTP는 데이터를 평문으로 전송하는 프로토콜이고, HTTPS는 여기에 TLS/SSL 암호화를 적용하여 보안을 강화한 프로토콜입니다.

HTTPS는 데이터 암호화, 무결성, 인증을 제공합니다. TLS 핸드셰이크 과정에서 서버 인증서를 통해 서버 신원을 검증하고, 대칭키를 교환한 후 암호화 통신을 시작합니다.

HTTP는 속도가 빠르지만 [중간자 공격(MITM)]에 취약합니다. HTTPS는 공개키 암호화로 대칭키를 안전하게 교환하ㅓㄴ 뒤, 대칭키로 데이터를 암호화하여 성능과 보안을 모두 확보합니다. TLS 1.3에서는 핸드셰이크 과정을 단축하여 지연을 줄이고, 최신 암호 알고리즘을 적용했습니다.

---
CORS란 무엇이며, 왜 필요한가요?
[CORS(Cross-Origin Resource Sharing)]는 브라우저가 보안상의 이유로 다른 출처(origin)의 리소스 요청을 제한하는 정책을 제어하기 위한 메커니즘입니다.

동일 출처 정책(Same-Origin Policy) 때문에 브라우저는 기본적으로 다른 도메인의 API 요청을 차단합니다. CORS는 서버가 허용 헤더를 설정하여 이를 예외적으로 허용할 수 있게 합니다.

예를 들어 http://example.com에서 http://api.example.org 로 요청할 경우, 브라우저는 OPTIONS 예비 요청(Preflight)을 보내 서버의 허용 여부를 확인합니다. 서버가 Access - Control - Allow - Origin, Methods, Headers를 올바르게 설정하면 본 요청이 진행됩니다. CORS 설정이 잘못되면 프론트엔드 개발 중 API 호출이 실패할 수 있습니다.