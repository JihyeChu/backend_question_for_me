# Part 운영체제

* [프로세스와 스레드의 차이](#프로세스와-스레드의-차이) 
* [컨텍스트 스위칭과 비용이 드는 이유](#컨텍스트-스위칭과-비용이-드는-이유)
* [프로세스 상태 전이](#프로세스-상태-전이)
* [동기와 비동기의 차이](#동기와-비동기의-차이)
* [멀티스레드 프로그래밍의 장단점](#멀티스레드-프로그래밍의-장단점)
* [스레드 안전의 의미와 구현 방법](#스레드-안전의-의미와-구현-방법)
---
## 프로세스와 스레드의 차이
프로세스는 실행중인 프로그램으로, 운영체제로부터 CPU, 메모리, 파일 핸들 등 독립적인 자원을 할당받아 동작하는 단위입니다. 스레드는 이러한 프로세스 내부의 실행 흐름을 나타내는 최소 단위이며, 프로세스 내에서 코드, 데이터, 힙 영역은 공유하되 스택은 개별적으로 가진다.

프로세스는 메모리 공간이 완전히 분리되어 있어 다른 프로세스와의 통신을 위해 파이프, 소켓, 공유 메모리와 같은 [IPC 기법](../Programming%20Terminology/README.md#ipc-기법)이 필요합니다. 반면, 스레드는 같은 메모리 공간을 공유하므로 통신이 상대적으로 빠르고 컨텍스트 스위칭의 비용이 적다. 그러나 스레드 간 자원 공유로 인해 동기화 문제와 경쟁 상태가 발생할 수 있으며, 이를 방치하면 데이터 불일치나 프로그램 오류로 이어질 수 있습니다.

예를 들어 크롬 부라우저가 각 탭을 별도의 프로세스로 실행하여 안정성을 높이는 것이 대표적이라고 할 수 있습니다.

---
## 컨텍스트 스위칭과 비용이 드는 이유
컨텍스트 스위칭은 CPU가 현재 실행중인 작업의 상태를 저장하고, 다른 작업의 상태를 불러와 실행을 전환하는 과정을 의미합니다. 이 과정에서 레지스터 값, 프로그램 카운터, 스택 포인터 같은 정보가 [PCB](../Programming%20Terminology/README.md#pcb)나 [TCB](../Programming%20Terminology/README.md#tcb)에 저장됩니다.

프로세스 전환은 서로 다른 주소 공간을 사용하므로 페이지 테이블 교체, [TLB](../Programming%20Terminology/README.md/#tlb)(Translation Lookaside Buffer) 초기화, 캐시 무효화와 같은 작업이 수행되어 상당한 비용이 발생한다. 스레드 전환은 같은 주소 공간을 공유하므로 메모리 매핑 변경이 필요 없어 상대적으로 가볍다. 하지만 전환이 지나치게 빈번하면 CPU가 실제 연산보다 상태 저장과 복원에 더 많은 시간을 소비하게 되어 시스템 전체 성능이 저하될 수 있다.

스레드를 과도하게 생성하거나 [I/O](../Programming%20Terminology/README.md/#io) 작업을 동기 방식으로 처리하여 컨텍스트 스위칭이 폭증하는 경우, TPS가 급격히 하락하고 응답 지연이 증가하는 문제가 발생한다. 이를 방지하기 위해 스레드풀 크기를 하드웨어 자원과 워크로드 특성에 맞게 조정하고, 블로킹 I/O 대신 비동기 처리 방식을 활용하는 것이 바람직하다.

---
## 프로세스 상태 전이
프로세스는 실행 과정에서 생성, 준비, 실행, 대기, 종료의 다섯 가지 상태를 거칩니다. 각 상태 전이는 스케줄러의 CPU 할당, 입출력 요청, [인터럽트](../Programming%20Terminology/README.md#인터럽트) 발생 등 다양한 이벤트에 의해 발성합니다.

예를 들면 준비 상태에 있는 프로세스가 CPU를 할당받으면 실행 상태로 전환되고, 실행 중 I/O 요청이 발생하면 대기 상태로 전환됩니다. 대기 상태에서 I/O가 완료되면 다시 준비 상태로 돌아가고, 모든 작업을 마치면 종료 상태로 진입합니다. 선점형 운영체제에서는 타임 슬아이스가 만료되면 실행 상태에서 준비 상태로 전환되는 일이 빈번히 발생하며, 우선순위 기반 스케줄러에서는 이러한 전환이 더욱 자주 일어납니다.

---
## 동기와 비동기의 차이
동기는 요청한 작업이 끝날 때까지 결과를 기다린 후 다음 작업을 수행하는 방식이며, 비동기는 요청 후 결과를 기다리지 않고 다른 작업을 병행하는 방식입니다. 동기 방식은 구현이 단순하고 직관적이지만 대기 시간이 길어질 수 있으며, 비동기 방식은 응답 속도가 빨라지고 자원 활용 효율이 높아질 수 있습니다.

동기/비동기와 별개로 블로킹/논블로킹 개념이 존재하는데 블로킹은 호출한 측이 제어권을 넘겨 작업이 끝날 때까지 대기하는 방식이고, 논블로킹은 제어권을 즉시 반환받아 다른 작업을 수행하는 방식입니다. 동기 블로킹은 가장 단순한 형태이며, 비동기 논블로킹은 고성능 서버나 이벤트 기반 시스템에서 주로 사용됩니다.

동시/비동기는 서비스의 특성에 따라 적절한 방식을 선택하는 것이 중요합니다.

-- -
## 멀티스레드 프로그래밍의 장단점
멀티스레드 프로그래밍은 하나의 프로세스에서 여러 스레드를 생성하여 병렬로 작업을 수행하는 기법입니다. 스레드들은 같은 메모리 공간을 공유하므로 데이터 교환이 빠르고, 자원 사용 효율이 높다.

장점으로는 프로세스보다 컨텍스트 스위칭이 빠르고, 메모리 사용량이 적으며, 작업 병렬화를 통해 응답 속도를 높일 수 있다는 점이 있습니다.

단점으로는 공유 자원에 대한 동기화 부담이 크고, 한 스레드의 오류가 전체 프로세스에 영향을 미칠 수 있으며, 디버깅이 어렵다는 점이 있습니다.

웹 서버에서 요청 처리 스레드를 풀로 관리하여 대규모 트래픽을 효율적으로 처리하는 방식도 있지만 락 경쟁이 심하면 오히려 성능이 저하될 수 있으므로, 락 범위를 최소화하거나 불변 객체를 사용해 동기화를 줄이는 방식이 선호됩니다.

---
## 스레드 안전의 의미와 구현 방법
스레드 안전이란 여러 스레드가 동시에 같은 객체나 메서드에 접근하더라도 프로그램의 동작 결과가 일관성을 유지하는 상태를 의미합니다. 즉, 동시 접근으로 인한 데이터 손상이나 예기치 않은 동작이 발생하지 않는 것을 보장합니다.

이를 구현하기 위해 동기화(synchronization), 불변 객체, 스레드 지역 변수, 원자적 연산(Atomic Operation) 등을 사용할 수 있습니다. Java의 경우 synchronized 키워드, java.util.concurrent 패키지의 동시성 컬렉션, AtomicInter 같은 클래스들이 대표적인 구현 수단입니다. 다만 동기화를 과도하게 사용하면 락 경쟁으로 인한 성능 저하가 발생할 수 있으므로, 필요한 최소 범위에서만 사용해야 합니다.