# Part 운영체제

* [프로세스와 스레드의 차이](#프로세스와-스레드의-차이) 
* [컨텍스트 스위칭과 비용이 드는 이유](#컨텍스트-스위칭과-비용이-드는-이유)
* [프로세스 상태 전이](#프로세스-상태-전이)
* [동기와 비동기의 차이](#동기와-비동기의-차이)
* [멀티스레드 프로그래밍의 장단점](#멀티스레드-프로그래밍의-장단점)
* [스레드 안전의 의미와 구현 방법](#스레드-안전의-의미와-구현-방법)
---
## 프로세스와 스레드의 차이
[프로세스](../Programming%20Terminology/README.md#프로세스)는 실행중인 프로그램으로, 운영체제로부터 CPU, 메모리, 파일 핸들 등 독립적인 자원을 할당받아 동작하는 단위입니다. 
[스레드](../Programming%20Terminology/README.md#스레드)는 이러한 프로세스 내부의 실행 흐름을 나타내는 최소 단위이며, 프로세스 내에서 코드, 데이터, 힙 영역은 공유하되 스택은 개별적으로 가진다.

프로세스는 메모리 공간이 완전히 분리되어 있어 다른 프로세스와의 통신을 위해 파이프, 소켓, 공유 메모리와 같은 [IPC 기법](../Programming%20Terminology/README.md#ipc-기법)이 필요합니다. 반면, 스레드는 같은 메모리 공간을 공유하므로 통신이 상대적으로 빠르고 컨텍스트 스위칭의 비용이 적다. 그러나 스레드 간 자원 공유로 인해 동기화 문제와 경쟁 상태가 발생할 수 있으며, 이를 방치하면 데이터 불일치나 프로그램 오류로 이어질 수 있습니다.

예를 들어 크롬 부라우저가 각 탭을 별도의 프로세스로 실행하여 안정성을 높이는 것이 대표적이라고 할 수 있습니다.


---
## 컨텍스트 스위칭과 비용이 드는 이유 
컨텍스트 스위칭은 CPU가 현재 실행중인 작업의 상태를 저장하고, 다른 작업의 상태를 불러와 실행을 전환하는 과정을 의미합니다. 이 과정에서 레지스터 값, 프로그램 카운터, 스택 포인터 같은 정보가 [PCB](../Programming%20Terminology/README.md#pcb)나 [TCB](../Programming%20Terminology/README.md#tcb)에 저장됩니다.

프로세스 전환은 서로 다른 주소 공간을 사용하므로 페이지 테이블 교체, [TLB](../Programming%20Terminology/README.md/#tlb)(Translation Lookaside Buffer) 초기화, 캐시 무효화와 같은 작업이 수행되어 상당한 비용이 발생한다. 스레드 전환은 같은 주소 공간을 공유하므로 메모리 매핑 변경이 필요 없어 상대적으로 가볍다. 하지만 전환이 지나치게 빈번하면 CPU가 실제 연산보다 상태 저장과 복원에 더 많은 시간을 소비하게 되어 시스템 전체 성능이 저하될 수 있다.

스레드를 과도하게 생성하거나 [I/O](../Programming%20Terminology/README.md/#io) 작업을 동기 방식으로 처리하여 컨텍스트 스위칭이 폭증하는 경우, TPS가 급격히 하락하고 응답 지연이 증가하는 문제가 발생한다. 이를 방지하기 위해 스레드풀 크기를 하드웨어 자원과 워크로드 특성에 맞게 조정하고, 블로킹 I/O 대신 비동기 처리 방식을 활용하는 것이 바람직하다.


---
## 프로세스 상태 전이
프로세스는 실행 과정에서 생성, 준비, 실행, 대기, 종료의 다섯 가지 상태를 거칩니다. 각 상태 전이는 스케줄러의 CPU 할당, 입출력 요청, [인터럽트](../Programming%20Terminology/README.md#인터럽트) 발생 등 다양한 이벤트에 의해 발성합니다.

예를 들면 준비 상태에 있는 프로세스가 CPU를 할당받으면 실행 상태로 전환되고, 실행 중 I/O 요청이 발생하면 대기 상태로 전환됩니다. 대기 상태에서 I/O가 완료되면 다시 준비 상태로 돌아가고, 모든 작업을 마치면 종료 상태로 진입합니다. 선점형 운영체제에서는 타임 슬아이스가 만료되면 실행 상태에서 준비 상태로 전환되는 일이 빈번히 발생하며, 우선순위 기반 스케줄러에서는 이러한 전환이 더욱 자주 일어납니다.


---
## 동기와 비동기의 차이
동기는 요청한 작업이 끝날 때까지 결과를 기다린 후 다음 작업을 수행하는 방식이며, 비동기는 요청 후 결과를 기다리지 않고 다른 작업을 병행하는 방식입니다. 동기 방식은 구현이 단순하고 직관적이지만 대기 시간이 길어질 수 있으며, 비동기 방식은 응답 속도가 빨라지고 자원 활용 효율이 높아질 수 있습니다.

동기/비동기와 별개로 블로킹/논블로킹 개념이 존재하는데 블로킹은 호출한 측이 제어권을 넘겨 작업이 끝날 때까지 대기하는 방식이고, 논블로킹은 제어권을 즉시 반환받아 다른 작업을 수행하는 방식입니다. 동기 블로킹은 가장 단순한 형태이며, 비동기 논블로킹은 고성능 서버나 이벤트 기반 시스템에서 주로 사용됩니다.

동시/비동기는 서비스의 특성에 따라 적절한 방식을 선택하는 것이 중요합니다.


---
## 멀티스레드 프로그래밍의 장단점
멀티스레드 프로그래밍은 하나의 프로세스에서 여러 스레드를 생성하여 병렬로 작업을 수행하는 기법입니다. 스레드들은 같은 메모리 공간을 공유하므로 데이터 교환이 빠르고, 자원 사용 효율이 높다.

장점으로는 프로세스보다 컨텍스트 스위칭이 빠르고, 메모리 사용량이 적으며, 작업 병렬화를 통해 응답 속도를 높일 수 있다는 점이 있습니다.

단점으로는 공유 자원에 대한 동기화 부담이 크고, 한 스레드의 오류가 전체 프로세스에 영향을 미칠 수 있으며, 디버깅이 어렵다는 점이 있습니다.

웹 서버에서 요청 처리 스레드를 풀로 관리하여 대규모 트래픽을 효율적으로 처리하는 방식도 있지만 락 경쟁이 심하면 오히려 성능이 저하될 수 있으므로, 락 범위를 최소화하거나 불변 객체를 사용해 동기화를 줄이는 방식이 선호됩니다.

---
## 스레드 안전의 의미와 구현 방법
스레드 안전이란 여러 스레드가 동시에 같은 객체나 메서드에 접근하더라도 프로그램의 동작 결과가 일관성을 유지하는 상태를 의미합니다. 즉, 동시 접근으로 인한 데이터 손상이나 예기치 않은 동작이 발생하지 않는 것을 보장합니다.

이를 구현하기 위해 동기화(synchronization), 불변 객체, 스레드 지역 변수, 원자적 연산(Atomic Operation) 등을 사용할 수 있습니다. Java의 경우 synchronized 키워드, java.util.concurrent 패키지의 동시성 컬렉션, AtomicInter 같은 클래스들이 대표적인 구현 수단입니다. 다만 동기화를 과도하게 사용하면 락 경쟁으로 인한 성능 저하가 발생할 수 있으므로, 필요한 최소 범위에서만 사용해야 합니다.

---
## 프로세스 동기화와 필요성
*프로세스 동기화는 다중 프로세스나 스레드 환경에서 공유 자원에 대한 접근 순서를 제어하여 *데이터의 일관성과 무결성을 보장하는 기법입니다. 이를 소홀히 하면 [*Race Condition](../Programming%20Terminology/README.md#race-condition)이 발생해 실행 결과가 예측 불가능하게 됩니다.

*임계 구역에 대한 *상호 배제, *진행, *유한 대기 조건을 충족해야 합니다. 동기화를 구현하는 방식으로는 *뮤텍스(Mutex), *세마포어(Semaphore), *모니터(Monitor) 등이 있으며, 각각 자원 접근 가능 개수, 잠금 해제 권한 등에 차이가 있습니다.

*DB 트랜잭션 격리 수준이 높을수록 교착 상태가 발생하기 쉬운데, 이를 방지하기 위해 트랜잭션 순서를 통일하거나 타임아웃을 설정해 자동 회복하는 방식이 사용됩니다.

---
## 기아 상태와 해결방법
*Starvation 기아 상태란 <b>자원 경쟁 상황에서 특정 작업이 자원 할당 기회를 거의 또는 전혀 얻지 못해 무한히 대기하는 상태</b>를 말합니다. 주로 <b>우선 순위 스케줄링</b>에서 낮은 작업이 계속 밀려나는 경우에 발생합니다.

해결 방법으로는 *에이징(Aging) 기법이 있습니다. 이는 대기 시간이 길어질수록 우선순위를 점진적으로 높여 기아 상태를 방지합니다. 또한 *라운드 로빈(Round Robin) 같은 공정한 CPU 스케줄링을 적용하거나, 자원 요청 제한 정책을 통해 특정 프로세스가 자원을 독점하지 못하게 할 수도 있습니다.

---
## 세마포어와 뮤텍스의 차이
*세마포어(Semaphore)는 여러 프로세스나 스레드가 공유 자원에 접근할 수 있는 동시 허용 개수를 제어하는 동기화 도구입니다. 반면 *뮤텍스(Mutex)는 한 번에 하나의 프로세스 또는 스레드만 자원에 접근하도록 허용하는 잠금 메커니즘입니다.

세마포어는 카운팅 세마포어(여러 접근 허용)와 이진 세마포어(뮤텍스와 유사)로 나뉘며, 다른 스레드가 세마포어를 해제할 수 있습니다. 반면 뮤텍스는 잠금을 획득한 스레드만이 잠금을 해제할 수 있습니다.

---
## 가상 메모리와 동작 원리
*가상 메모리는 프로세스가 실제 메모리 크기와 상관없이 연속된 주소 공간을 사용하는 것처럼 보이게 하는 메모리 관리 기법입니다. 운영체제는 이를 위해 *페이지 테이블을 사용하며, *가상 주소를 *물리 주소로 변환합니다.

이 과정에서 필요한 데이터가 물리 메모리에 없으면 *페이지 폴트(Page Fault)가 발생하고, 보조 저장장치의 스왑 영역에서 데이트를 불러옵니다. 이로써 메모리 공간을 효율적으로 사용할 수 있지만 디스크 접근 속도가 RAM보다 훨씬 느리기 때문에 *페이지 폴트가 잦으면 성능이 저하됩니다.

*JVM이 *힙 메모리를 초과하면 *GC가 발생하고, 심한 경우 *OOM이 발생합니다. OS 레벨에서는 *스왑 공간 사용이 잦아지면 응답 속도가 급격히 떨어지므로, 메모리 누수를 방지하고 적정 메모리 사용량을 유지하는 것이 중요합니다.

---
## 캐시의 지역성과 성능 최적화
*캐시는 자주 사용되는 데이터를 빠르게 접근할 수 있도록 메모리나 디스크 일부에 저장하는 기술입니다. 캐시 성능은 *지역성(Locality)에 기반하며, 시간 지역성과 공간 지역성으로 나뉩니다. 

시간 지역성은 최근에 접근한 데이터에 다시 접근할 가능성이 높은 특성을 의미합니다. 공간 지역성은 특정 데이터 주변의 다른 데이터에도 접근할 가능성이 높은 특성을 말합니다. CPU 캐시, DB 인덱스 캐시, 웹 브라우저 캐시 모두 이러한 원리를 활용합니다.

---
## 페이징과 세그먼테이션의 차이
*페이징은 메모리를 고정 크기의 블록(페이지)으로 나누어 관리하는 방식이고, 세그먼테이션은 논리적인 의미 단위(세그먼트)로 나누는 방식입니다.  페이징은 외부 단편화를 줄이지만 내부 단편화가 발생할 수 있고, *세그먼테이션은 내부 단편화를 줄이지만 외부 단편화가 발생할 수 있습니다.

페이징에서는 페이지 테이블을 사용해 가상 주소를 물리 주소로 매핑합니다. 세그먼테이션은 세그먼트 테이블을 사용하며, 각 세그먼트는 길이와 시작 주소를 가집니다. 현대 OS는 두 방식을 혼합한 페이징 기반 세그먼테이션을 많이 사용합니다.

---
## 페이지 교체 알고리즘
*페이지 폴트 발생 시 어떤 페이지를 내보낼지 결정하는 방식입니다. 대표적으로 *FIFO, *LRU, *LFU, *Optimal 알고리즘이 있습니다.

---
## 스레싱
*Thrashing 스레싱은 프로세스 실행보다 페이지 교체에 더 많은 시간이 소요되는 상태를 말합니다. 이는 과도한 다중 프로그래밍으로 물리 메모리보다 많은 작업이 동시에 수행될 때 발생합니다.

스레싱이 발생하면 CPU 이용률이 급격히 떨어지고, 응답 시간이 비정상적으로 길어집니다. 해결  방법으로는 다중 프로그래밍의 정도를 줄이거나, *워킹 셋 모델을 사용해 필요한 페이지 집합을 메모리에 유지하는 방법이 있습니다.

---
## 인터럽트와 폴링의 차이
[인터럽트](../Programming%20Terminology/README.md#인터럽트)는 하드웨어나 소프트웨어가 CPU에 현재 작업을 중단하고 특정 처리를 수행하도록 알리는 신호입니다. *폴링은 CPU가 주기적으로 장치 상태를 확인하는 방식입니다.

인터럽트는 효율적인 자원 활용이 가능하지만, 폴링은 장치 상태를 계속 확인하므로 불필요한 CPU 자원을 소모합니다. 다만, 간단한 장치 제어에서는 폴링 구현이 더 단순할 수 있습니다.


---
## 커널 모드와 사용자 모드
*커널 모드는 OS의 핵심 기능에 직접 접근할 수 있는 모드이며, *사용자 모드는 제한된 권한으로 실행되는 모드입니다. 사용자 모드에서 커널 기능을 사용하려면 [시스템 콜(System call)](#시스템-콜)을 통해 커널 모드로 전환해야 합니다.

이 분리는 시스템 안정성과 보안을 위해 필요합니다. 사용자 모드에서 직접 하드웨어에 접근하면 시스템이 불안정해질 수 있기 때문입니다.

---
## 시스템 콜
시스템 콜은 사용자 프로그램이 OS 커널 기능을 요청하는 인터페이스입니다. 예를 들어 파일 열기, 읽기, 쓰기, 네트원크 소켕 생성 등은 시스템 콜을 통해 수행됩니다.

시스템 콜은 커널 모드로 전환되기 때문에 오버헤드가 발생할 수 있습니다. 호출 빈도가 많으면 성능에 영향을 줄 수 있습니다.

---
## 운영체제의 역할과 주요 기능
운영체제는 하드웨어와 소프트웨어를 중재하며, 자원 관리와 사용자 인터페이스를 제공하는 시스템 소프트 웨어입니다. 주요 기능에는 프로세스 관리, 메모리 관리. 파일 시스템 관리, 입출력 장치 관리, 보안 및 네트워크 관리 등이 있습니다.

운영체제는 멀티태스킹, 멀티스레딩, 가상 메모리, 인터럽트 처리 등의 기능을 통해 하드웨어 자원을 효율적으로 분배하고, 애플리케이션이 하드웨어의 세부 구현을 몰라도 동작할 수 있게 합니다.

서버의 운영체제는 안정성과 보안이 특히 중요하며, 성능 튜닝과 자원 모니터링을 통해 *SLA를 만족시키는 것이 핵심입니다.
